---
title: Java中四种创建对象的方式
date: 2018-05-07 17:40:14
updated: 2018-05-07 17:40:14
tags:
  - 创建对象
categories: 
  - Java
  - 面向对象
---

Java中有四种创建对象的方式

- 调用new语句创建对象
- 调用对象的clone()方法
- 运用反射手段创建对象
- 运用反序列化手段

本文对每种方式进行了详细的描述介绍。

<!-- more -->

# 调用new语句创建对象
```Java
// 使用java语言的关键字 new 创建对象，初始化对象数据　
MyObject mo = new MyObject() ;
```

# 调用对象的clone()方法
```Java
MyObject anotherObject = new MyObject();
MyObject object = anotherObject.clone();
```
使用 clone()方法克隆一个对象的步骤：
1. 被克隆的类要实现 Cloneable 接口。
2. 被克隆的类要重写 clone(）方法。

原型模式主要用于对象的复制，实现一个接口（实现Cloneable接口），重写一个方法（重写Object类中的clone方法），即完成了原型模式。

原型模式中的拷贝分为”浅拷贝”和”深拷贝”:
- 浅拷贝：对值类型的成员变量进行值的复制，对引用类型的成员变量只复制引用，不复制引用的对象.
- 深拷贝：对值类型的成员变量进行值的复制，对引用类型的成员变量也进行引用对象的复制.

（Object 类的 clone 方法只会拷贝对象中的基本数据类型的值，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。）

## 原型模式的优点
- 如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程。
- 使用原型模式创建对象比直接 new 一个对象在性能上要好的多，因为Object 类的 clone 方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。

## 原型模式的使用场景
因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。

比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。

# 运用反射手段创建对象
## 反射的定义
- 反射机制是在运行时， 对于任意一个类， 都能够知道这个类的所有属性和方法； 对于任意一个对象， 都能够调用它的任意一个方法。 在Java中，只要给定类的名字， 那么就可以通过反射机制来获得类的所有信息。
- 反射机制主要提供了以下功能：
    - 在运行时判定任意一个对象所属的类；
    - 在运行时创建对象；
    - 在运行时判定任意一个类所具有的成员变量和方法；
    - 在运行时调用任意一个对象的方法；
    - 生成动态代理。

## 哪里用到反射机制？
jdbc 中有一行代码：`Class.forName(‘com.mysql.jdbc.Driver.class’);//加载MySql的驱动类。`这就是反射。

现在很多框架都用到反射机制， hibernate， struts 都是用反射机制实
现的。

## 反射的实现方式
在 Java 中实现反射最重要的一步， 也是第一步就是获取Class对象，得到Class对象后可以通过该对象调用相应的方法来获取该类中的属性、方法以及调用该类中的方法。

有 4 种方法可以得到 Class 对象：
- `Class.forName(“类的路径” );`
- 类名.class
- 对象名.getClass()
- 如果是基本类型的包装类， 则可以通过调用包装类的 Type 属性来获得该包装类的 Class 对象, `Class<?> clazz = Integer.TYPE;`
## 实现Java反射的类
1. Class：它表示正在运行的 Java 应用程序中的类和接口。
2. Field：提供有关类或接口的属性信息， 以及对它的动态访问权限。
3. Constructor：提供关于类的单个构造方法的信息以及对它的访问权限
4. Method：提供关于类或接口中某个方法信息。

注意：Class类是Java反射中最重要的一个功能类，所有获取对象的信息(包括： 方法/属性/构造方法/访问权限)都需要它来实现。

## 反射机制的优缺点
### 优点
- 能够运行时动态获取类的实例， 大大提高程序的灵活性。
- 与 Java 动态编译相结合， 可以实现无比强大的功能。

### 缺点
- 使用反射的性能较低。Java反射是要解析字节码，将内存中的对象进行解析。
    - 解决方案：
        - 由于JDK的安全检查耗时较多， 所以通过setAccessible(true)的方式关闭安全检查来（取消对访问控制修饰符的检查） 提升反射速度。
        - 需要多次动态创建一个类的实例的时候，有缓存的写法会比没有缓存要快很多:
        - ReflectASM 工具类 ， 通过字节码生成的方式加快反射速度。
- 使用反射相对来说不安全，破坏了类的封装性，可以通过反射获取这个类的私有方法和属性。

# 运用反序列化手段
Java序列化是指把Java对象转换为字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。

## 为什么需要序列化与反序列化
我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等，而这些数据都会以二进制序列的形式在网络上传送。那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？答案是可以的。如何做到呢？这就需要Java序列化与反序列化了。换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。基本原理和网络通信是一致的，通过特殊的编码方式：写入数据将对象以及其内部数据编码，存在在数组或者文件里面然后发送到目的地后，再进行解码，读出数据。

当我们明晰了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。
- 实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）
- 利用序列化实现远程通信，即在网络上传送对象的字节序列。

## 对象序列化
- java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。只有实现了Serializable和Externalizable接口的类的对象才能被序列化。
- java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。
